"use strict";class e{value;_parent;tree;_key;_children=[];static createKey=()=>"n-"+Math.random().toString(36).slice(2,10);constructor(t,r=null,i=null){this.value=t,this._parent=r,this.tree=i,this._key=e.createKey()}__setKey(e){return this._key=e,this}__setParent(e){return this._parent=e,this}__setTree(e){return this.tree=e,this}__syncChildren(){const e=(t,r)=>{for(let i of t)i.__setParent(r).__setTree(r?.tree||null),e(i.children,i)};return e(this._children,this)}get depth(){let e=this._parent,t=0;for(;e;)t++,e=e.parent;return t}get root(){let e=this._parent,t=e;for(;e;)e=e.parent,e&&(t=e);return t}get key(){return this._key}get parent(){return this._parent}get children(){return this._children}get isLeaf(){return 0===this._children.length}get isRoot(){return null===this._parent}get siblings(){return this._parent?.children||[]}get siblingIndex(){return this.siblings.length?this.siblings.findIndex((e=>e.key===this._key)):-1}_assertSameTopRootNode(t){if(t instanceof e&&t.root!==this.root)throw new Error("Cannot proceed with a node from a different tree. (Use node's value instead.)")}_assertNotContains(t){if(t instanceof e&&this.contains(t.key))throw new Error("Cannot proceed, already contains. (Use node's value instead.)")}toJSON(){return{key:this._key,value:this.value,children:this._children}}deepClone(){const t=JSON.parse(JSON.stringify(this.toJSON(),((t,r)=>"key"===t?e.createKey():r))),r=new e(t.value,this._parent);r.__setKey(t.key);const i=(e,t)=>{for(let r of e){const e=t.appendChild(r.value).__setKey(r.key);i(r.children,e)}};return i(t.children,r),r}appendChild(t,r=!0){this._assertSameTopRootNode(t),this._assertNotContains(t);const i=t instanceof e?t:new e(t,this);return i.__setParent(this),this._children.push(i),r&&this.__syncChildren(),i}removeChild(e){const t=this._children.findIndex((t=>t.key===e));return!(t<0)&&(this._children.splice(t,1),this)}replaceChild(t,r){this._assertSameTopRootNode(r);const i=this._children.findIndex((e=>e.key===t));if(i<0)return!1;this._assertNotContains(r);const n=r instanceof e?r:new e(r,this);return n.__setParent(this),this._children[i]=n,this.__syncChildren(),this._children[i]}resetChildren(e=[]){return this._children=[],(e||[]).forEach((e=>this.appendChild(e,!1))),this.__syncChildren(),this}previousSibling(){if(this.siblings.length){const e=this.siblings.findIndex((e=>e.key===this._key));return this.siblings[e-1]||null}return null}nextSibling(){if(this.siblings.length){const e=this.siblings.findIndex((e=>e.key===this._key));return this.siblings[e+1]||null}return null}moveSiblingIndex(e){const t=this.siblingIndex;return this.siblings.length<2||((e=Math.min(e,this.siblings.length-1))<0&&(e=Math.max(0,this.siblings.length-1+e)),this.siblings.splice(e,0,this.siblings.splice(t,1)[0])),this}contains(e){if(!e)return!1;const t=r=>{for(let i of r){if(i.key===e)return!0;if(t(i.children))return!0}return!1};return t(this._children)}toString(){return"    ".repeat(this.depth)+this.value?.toString()}}exports.Tree=class{_root;constructor(e=null){this._root=e,this._root&&this._root.__setTree(this)}appendChild(t){return this._root?this._root.appendChild(t):(this._root=t instanceof e?t:new e(t),this._root.__setTree(this),this._root.__syncChildren(),this._root)}get root(){return this._root}*preOrderTraversal(e){if(e??=this._root,yield e,e?.children.length)for(let t of e.children)yield*this.preOrderTraversal(t)}*postOrderTraversal(e){if(e??=this._root,e?.children.length)for(let t of e.children)yield*this.postOrderTraversal(t);yield e}find(e){for(let t of this.preOrderTraversal())if(t.key===e)return t;return null}findBy(e,t=null){for(let r of this.preOrderTraversal()){if(t&&void 0!==r.value[t]&&r.value[t]===e)return r;if(!t&&r.value===e)return r}return null}findLCA(e,t){const r=(e,t,i)=>{if(!e||!t||!i)return null;if(e===t||e===i)return e;let n=0,s=null;for(const o of e.children){const h=r(o,t,i);if(h&&(n++,s=h),2===n)return e}return s};return r(this._root,this.find(e),this.find(t))}insert(e,t){const r=this.find(e);return!!r&&r.appendChild(t)}remove(e){if(!e)return!1;if(this._root?.key===e)return this._root=null,this;for(let t of this.preOrderTraversal())if(t.removeChild(e))return!0;return!1}_moveOrCopy(e,t,r){const i=this.find(e);if(!i)return!1;if(i.contains(t))throw new Error("Cyclic reference detected.");const n=this.find(t);return!!n&&(!n.contains(i.key)&&(r?(n.appendChild(i),this.remove(i.key)):n.appendChild(i.deepClone()),this))}move(e,t){return this._moveOrCopy(e,t,!0)}copy(e,t){return this._moveOrCopy(e,t,!1)}toJSON(){return this._root?.toJSON()}dump(){return JSON.stringify(this)}restore(t){let r=t;"string"==typeof t&&(r=JSON.parse(t));const i=(e,t)=>{for(let r of e){const e=t.appendChild(r.value,!1).__setKey(r.key);i(r.children,e)}},n=new e(r.value).__setKey(r.key);return i(r.children,n),this._root=n,this}size(e){return e??=this._root,e&&(e===this._root||this.contains(e?.key))?[...this.preOrderTraversal(e)].length:0}contains(e){return!!this._root?.contains(e)}toString(){return[...this.preOrderTraversal()].map((e=>e?.toString())).join("\n")}},exports.TreeNode=e;
